"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/glob/dist/esm/glob.js":
/*!********************************************!*\
  !*** ./node_modules/glob/dist/esm/glob.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* binding */ Glob)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var path_scurry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-scurry */ \"(rsc)/./node_modules/path-scurry/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/esm/pattern.js\");\n/* harmony import */ var _walker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./walker.js */ \"(rsc)/./node_modules/glob/dist/esm/walker.js\");\n\n\n\n\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * An object that can perform glob pattern traversals.\n */\nclass Glob {\n    absolute;\n    cwd;\n    root;\n    dot;\n    dotRelative;\n    follow;\n    ignore;\n    magicalBraces;\n    mark;\n    matchBase;\n    maxDepth;\n    nobrace;\n    nocase;\n    nodir;\n    noext;\n    noglobstar;\n    pattern;\n    platform;\n    realpath;\n    scurry;\n    stat;\n    signal;\n    windowsPathsNoEscape;\n    withFileTypes;\n    includeChildMatches;\n    /**\n     * The options provided to the constructor.\n     */\n    opts;\n    /**\n     * An array of parsed immutable {@link Pattern} objects.\n     */\n    patterns;\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */\n    constructor(pattern, opts) {\n        /* c8 ignore start */\n        if (!opts)\n            throw new TypeError('glob options required');\n        /* c8 ignore stop */\n        this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = '';\n        }\n        else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n            opts.cwd = (0,node_url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || '';\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth =\n            typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error('cannot set absolute and withFileTypes:true');\n        }\n        if (typeof pattern === 'string') {\n            pattern = [pattern];\n        }\n        this.windowsPathsNoEscape =\n            !!opts.windowsPathsNoEscape ||\n                opts.allowWindowsEscape ===\n                    false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map(p => p.replace(/\\\\/g, '/'));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError('base matching requires globstar');\n            }\n            pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`));\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = { ...opts, platform: this.platform };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined &&\n                opts.nocase !== opts.scurry.nocase) {\n                throw new Error('nocase option contradicts provided scurry option');\n            }\n        }\n        else {\n            const Scurry = opts.platform === 'win32' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryWin32\n                : opts.platform === 'darwin' ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryDarwin\n                    : opts.platform ? path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurryPosix\n                        : path_scurry__WEBPACK_IMPORTED_MODULE_2__.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs,\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === 'darwin' || this.platform === 'win32';\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug,\n        };\n        const mms = this.pattern.map(p => new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m) => {\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [[], []]);\n        this.patterns = matchSet.map((set, i) => {\n            const g = globParts[i];\n            /* c8 ignore start */\n            if (!g)\n                throw new Error('invalid pattern object');\n            /* c8 ignore stop */\n            return new _pattern_js__WEBPACK_IMPORTED_MODULE_3__.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...(await new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walk()),\n        ];\n    }\n    walkSync() {\n        return [\n            ...new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ?\n                    this.maxDepth + this.scurry.cwd.depth()\n                    : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches,\n            }).walkSync(),\n        ];\n    }\n    stream() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).stream();\n    }\n    streamSync() {\n        return new _walker_js__WEBPACK_IMPORTED_MODULE_4__.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ?\n                this.maxDepth + this.scurry.cwd.depth()\n                : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches,\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */\n    iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */\n    iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9nbG9iLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzQztBQUNHO0FBQ3FEO0FBQ3ZEO0FBQ2M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdEQUFlO0FBQ3RFLCtDQUErQyx5REFBZ0I7QUFDL0Qsc0NBQXNDLHdEQUFlO0FBQ3JELDBCQUEwQixtREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnREFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU87QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vZ2xvYi5qcz8wM2YwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1pbmltYXRjaCB9IGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgeyBmaWxlVVJMVG9QYXRoIH0gZnJvbSAnbm9kZTp1cmwnO1xuaW1wb3J0IHsgUGF0aFNjdXJyeSwgUGF0aFNjdXJyeURhcndpbiwgUGF0aFNjdXJyeVBvc2l4LCBQYXRoU2N1cnJ5V2luMzIsIH0gZnJvbSAncGF0aC1zY3VycnknO1xuaW1wb3J0IHsgUGF0dGVybiB9IGZyb20gJy4vcGF0dGVybi5qcyc7XG5pbXBvcnQgeyBHbG9iU3RyZWFtLCBHbG9iV2Fsa2VyIH0gZnJvbSAnLi93YWxrZXIuanMnO1xuLy8gaWYgbm8gcHJvY2VzcyBnbG9iYWwsIGp1c3QgY2FsbCBpdCBsaW51eC5cbi8vIHNvIHdlIGRlZmF1bHQgdG8gY2FzZS1zZW5zaXRpdmUsIC8gc2VwYXJhdG9yc1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3N0cmluZycpID9cbiAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAnbGludXgnO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcGVyZm9ybSBnbG9iIHBhdHRlcm4gdHJhdmVyc2Fscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdsb2Ige1xuICAgIGFic29sdXRlO1xuICAgIGN3ZDtcbiAgICByb290O1xuICAgIGRvdDtcbiAgICBkb3RSZWxhdGl2ZTtcbiAgICBmb2xsb3c7XG4gICAgaWdub3JlO1xuICAgIG1hZ2ljYWxCcmFjZXM7XG4gICAgbWFyaztcbiAgICBtYXRjaEJhc2U7XG4gICAgbWF4RGVwdGg7XG4gICAgbm9icmFjZTtcbiAgICBub2Nhc2U7XG4gICAgbm9kaXI7XG4gICAgbm9leHQ7XG4gICAgbm9nbG9ic3RhcjtcbiAgICBwYXR0ZXJuO1xuICAgIHBsYXRmb3JtO1xuICAgIHJlYWxwYXRoO1xuICAgIHNjdXJyeTtcbiAgICBzdGF0O1xuICAgIHNpZ25hbDtcbiAgICB3aW5kb3dzUGF0aHNOb0VzY2FwZTtcbiAgICB3aXRoRmlsZVR5cGVzO1xuICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM7XG4gICAgLyoqXG4gICAgICogVGhlIG9wdGlvbnMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIG9wdHM7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgcGFyc2VkIGltbXV0YWJsZSB7QGxpbmsgUGF0dGVybn0gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBwYXR0ZXJucztcbiAgICAvKipcbiAgICAgKiBBbGwgb3B0aW9ucyBhcmUgc3RvcmVkIGFzIHByb3BlcnRpZXMgb24gdGhlIGBHbG9iYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIEdsb2JPcHRpb25zfSBmb3IgZnVsbCBvcHRpb25zIGRlc2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhIHByZXZpb3VzIGBHbG9iYCBvYmplY3QgY2FuIGJlIHBhc3NlZCBhcyB0aGVcbiAgICAgKiBgR2xvYk9wdGlvbnNgIHRvIGFub3RoZXIgYEdsb2JgIGluc3RhbnRpYXRpb24gdG8gcmUtdXNlIHNldHRpbmdzXG4gICAgICogYW5kIGNhY2hlcyB3aXRoIGEgbmV3IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUcmF2ZXJzYWwgZnVuY3Rpb25zIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcnVuIHRoZSB3YWxrXG4gICAgICogYWdhaW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0cykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2xvYiBvcHRpb25zIHJlcXVpcmVkJyk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2l0aEZpbGVUeXBlcyA9ICEhb3B0cy53aXRoRmlsZVR5cGVzO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0cy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZG90ID0gISFvcHRzLmRvdDtcbiAgICAgICAgdGhpcy5kb3RSZWxhdGl2ZSA9ICEhb3B0cy5kb3RSZWxhdGl2ZTtcbiAgICAgICAgdGhpcy5ub2RpciA9ICEhb3B0cy5ub2RpcjtcbiAgICAgICAgdGhpcy5tYXJrID0gISFvcHRzLm1hcms7XG4gICAgICAgIGlmICghb3B0cy5jd2QpIHtcbiAgICAgICAgICAgIHRoaXMuY3dkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5jd2QgaW5zdGFuY2VvZiBVUkwgfHwgb3B0cy5jd2Quc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XG4gICAgICAgICAgICBvcHRzLmN3ZCA9IGZpbGVVUkxUb1BhdGgob3B0cy5jd2QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3dkID0gb3B0cy5jd2QgfHwgJyc7XG4gICAgICAgIHRoaXMucm9vdCA9IG9wdHMucm9vdDtcbiAgICAgICAgdGhpcy5tYWdpY2FsQnJhY2VzID0gISFvcHRzLm1hZ2ljYWxCcmFjZXM7XG4gICAgICAgIHRoaXMubm9icmFjZSA9ICEhb3B0cy5ub2JyYWNlO1xuICAgICAgICB0aGlzLm5vZXh0ID0gISFvcHRzLm5vZXh0O1xuICAgICAgICB0aGlzLnJlYWxwYXRoID0gISFvcHRzLnJlYWxwYXRoO1xuICAgICAgICB0aGlzLmFic29sdXRlID0gb3B0cy5hYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzID0gb3B0cy5pbmNsdWRlQ2hpbGRNYXRjaGVzICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub2dsb2JzdGFyID0gISFvcHRzLm5vZ2xvYnN0YXI7XG4gICAgICAgIHRoaXMubWF0Y2hCYXNlID0gISFvcHRzLm1hdGNoQmFzZTtcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0cy5tYXhEZXB0aCA9PT0gJ251bWJlcicgPyBvcHRzLm1heERlcHRoIDogSW5maW5pdHk7XG4gICAgICAgIHRoaXMuc3RhdCA9ICEhb3B0cy5zdGF0O1xuICAgICAgICB0aGlzLmlnbm9yZSA9IG9wdHMuaWdub3JlO1xuICAgICAgICBpZiAodGhpcy53aXRoRmlsZVR5cGVzICYmIHRoaXMuYWJzb2x1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGFic29sdXRlIGFuZCB3aXRoRmlsZVR5cGVzOnRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRzLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ubWFwKHAgPT4gcC5yZXBsYWNlKC9cXFxcL2csICcvJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoQmFzZSkge1xuICAgICAgICAgICAgaWYgKG9wdHMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Jhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLm1hcChwID0+IChwLmluY2x1ZGVzKCcvJykgPyBwIDogYC4vKiovJHtwfWApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0gfTtcbiAgICAgICAgaWYgKG9wdHMuc2N1cnJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNjdXJyeSA9IG9wdHMuc2N1cnJ5O1xuICAgICAgICAgICAgaWYgKG9wdHMubm9jYXNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRzLm5vY2FzZSAhPT0gb3B0cy5zY3Vycnkubm9jYXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2Nhc2Ugb3B0aW9uIGNvbnRyYWRpY3RzIHByb3ZpZGVkIHNjdXJyeSBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFNjdXJyeSA9IG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyBQYXRoU2N1cnJ5V2luMzJcbiAgICAgICAgICAgICAgICA6IG9wdHMucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gUGF0aFNjdXJyeURhcndpblxuICAgICAgICAgICAgICAgICAgICA6IG9wdHMucGxhdGZvcm0gPyBQYXRoU2N1cnJ5UG9zaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUGF0aFNjdXJyeTtcbiAgICAgICAgICAgIHRoaXMuc2N1cnJ5ID0gbmV3IFNjdXJyeSh0aGlzLmN3ZCwge1xuICAgICAgICAgICAgICAgIG5vY2FzZTogb3B0cy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgZnM6IG9wdHMuZnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vY2FzZSA9IHRoaXMuc2N1cnJ5Lm5vY2FzZTtcbiAgICAgICAgLy8gSWYgeW91IGRvIG5vY2FzZTp0cnVlIG9uIGEgY2FzZS1zZW5zaXRpdmUgZmlsZSBzeXN0ZW0sIHRoZW5cbiAgICAgICAgLy8gd2UgbmVlZCB0byB1c2UgcmVnZXhwcyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yIG5vbi1tYWdpY1xuICAgICAgICAvLyBwYXRoIHBvcnRpb25zLCBiZWNhdXNlIHN0YXR0aW5nIGBhQmNgIHdvbid0IHJldHVybiByZXN1bHRzXG4gICAgICAgIC8vIGZvciB0aGUgZmlsZSBgQWJDYCBmb3IgZXhhbXBsZS5cbiAgICAgICAgY29uc3Qgbm9jYXNlTWFnaWNPbmx5ID0gdGhpcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHwgdGhpcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgY29uc3QgbW1vID0ge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBub2Nhc2UgYmFzZWQgb24gcGxhdGZvcm1cbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBkb3Q6IHRoaXMuZG90LFxuICAgICAgICAgICAgbWF0Y2hCYXNlOiB0aGlzLm1hdGNoQmFzZSxcbiAgICAgICAgICAgIG5vYnJhY2U6IHRoaXMubm9icmFjZSxcbiAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICBub2Nhc2VNYWdpY09ubHksXG4gICAgICAgICAgICBub2NvbW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBub2V4dDogdGhpcy5ub2V4dCxcbiAgICAgICAgICAgIG5vbmVnYXRlOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pemF0aW9uTGV2ZWw6IDIsXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlOiB0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlLFxuICAgICAgICAgICAgZGVidWc6ICEhdGhpcy5vcHRzLmRlYnVnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtbXMgPSB0aGlzLnBhdHRlcm4ubWFwKHAgPT4gbmV3IE1pbmltYXRjaChwLCBtbW8pKTtcbiAgICAgICAgY29uc3QgW21hdGNoU2V0LCBnbG9iUGFydHNdID0gbW1zLnJlZHVjZSgoc2V0LCBtKSA9PiB7XG4gICAgICAgICAgICBzZXRbMF0ucHVzaCguLi5tLnNldCk7XG4gICAgICAgICAgICBzZXRbMV0ucHVzaCguLi5tLmdsb2JQYXJ0cyk7XG4gICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICB9LCBbW10sIFtdXSk7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBtYXRjaFNldC5tYXAoKHNldCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZyA9IGdsb2JQYXJ0c1tpXTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKCFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXR0ZXJuIG9iamVjdCcpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0dGVybihzZXQsIGcsIDAsIHRoaXMucGxhdGZvcm0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FsaygpIHtcbiAgICAgICAgLy8gV2Fsa2VycyBhbHdheXMgcmV0dXJuIGFycmF5IG9mIFBhdGggb2JqZWN0cywgc28gd2UganVzdCBoYXZlIHRvXG4gICAgICAgIC8vIGNvZXJjZSB0aGVtIGludG8gdGhlIHJpZ2h0IHNoYXBlLiAgSXQgd2lsbCBoYXZlIGFscmVhZHkgY2FsbGVkXG4gICAgICAgIC8vIHJlYWxwYXRoKCkgaWYgdGhlIG9wdGlvbiB3YXMgc2V0IHRvIGRvIHNvLCBzbyB3ZSBrbm93IHRoYXQncyBjYWNoZWQuXG4gICAgICAgIC8vIHN0YXJ0IG91dCBrbm93aW5nIHRoZSBjd2QsIGF0IGxlYXN0XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi4oYXdhaXQgbmV3IEdsb2JXYWxrZXIodGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICAgICAgfSkud2FsaygpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2Fsa1N5bmMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5uZXcgR2xvYldhbGtlcih0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgICAgICB9KS53YWxrU3luYygpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtKCk7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtU3luYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN5bmMgaXRlcmF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGEgR2VuZXJhdG9yIHRoYXRcbiAgICAgKiBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGl0ZXJhdGVTeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1TeW5jKClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZVN5bmMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBhc3luYyBpdGVyYXRpb24gZnVuY3Rpb24uIFJldHVybnMgYW4gQXN5bmNHZW5lcmF0b3IgdGhhdFxuICAgICAqIGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgaXRlcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/has-magic.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/esm/has-magic.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasMagic: () => (/* binding */ hasMagic)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nconst hasMagic = (pattern, options = {}) => {\n    if (!Array.isArray(pattern)) {\n        pattern = [pattern];\n    }\n    for (const p of pattern) {\n        if (new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p, options).hasMagic())\n            return true;\n    }\n    return false;\n};\n//# sourceMappingURL=has-magic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9oYXMtbWFnaWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9oYXMtbWFnaWMuanM/NDc5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNaW5pbWF0Y2ggfSBmcm9tICdtaW5pbWF0Y2gnO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGF0dGVybnMgcHJvdmlkZWQgY29udGFpbiBhbnkgbWFnaWMgZ2xvYiBjaGFyYWN0ZXJzLFxuICogZ2l2ZW4gdGhlIG9wdGlvbnMgcHJvdmlkZWQuXG4gKlxuICogQnJhY2UgZXhwYW5zaW9uIGlzIG5vdCBjb25zaWRlcmVkIFwibWFnaWNcIiB1bmxlc3MgdGhlIGBtYWdpY2FsQnJhY2VzYCBvcHRpb25cbiAqIGlzIHNldCwgYXMgYnJhY2UgZXhwYW5zaW9uIGp1c3QgdHVybnMgb25lIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBTbyBhIHBhdHRlcm4gbGlrZSBgJ3h7YSxifXknYCB3b3VsZCByZXR1cm4gYGZhbHNlYCwgYmVjYXVzZSBgJ3hheSdgIGFuZFxuICogYCd4YnknYCBib3RoIGRvIG5vdCBjb250YWluIGFueSBtYWdpYyBnbG9iIGNoYXJhY3RlcnMsIGFuZCBpdCdzIHRyZWF0ZWQgdGhlXG4gKiBzYW1lIGFzIGlmIHlvdSBoYWQgY2FsbGVkIGl0IG9uIGBbJ3hheScsICd4YnknXWAuIFdoZW4gYG1hZ2ljYWxCcmFjZXM6dHJ1ZWBcbiAqIGlzIGluIHRoZSBvcHRpb25zLCBicmFjZSBleHBhbnNpb24gX2lzXyB0cmVhdGVkIGFzIGEgcGF0dGVybiBoYXZpbmcgbWFnaWMuXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNNYWdpYyA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgcGF0dGVybiA9IFtwYXR0ZXJuXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwIG9mIHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKG5ldyBNaW5pbWF0Y2gocCwgb3B0aW9ucykuaGFzTWFnaWMoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLW1hZ2ljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/has-magic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/ignore.js":
/*!**********************************************!*\
  !*** ./node_modules/glob/dist/esm/ignore.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ignore: () => (/* binding */ Ignore)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/esm/pattern.js\");\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\n\nconst defaultPlatform = (typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string') ?\n    process.platform\n    : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n    relative;\n    relativeChildren;\n    absolute;\n    absoluteChildren;\n    platform;\n    mmopts;\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform, }) {\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true,\n        };\n        for (const ign of ignored)\n            this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(ign, this.mmopts);\n        for (let i = 0; i < mm.set.length; i++) {\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */\n            if (!parsed || !globParts) {\n                throw new Error('invalid pattern object');\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while (parsed[0] === '.' && globParts[0] === '.') {\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */\n            const p = new _pattern_js__WEBPACK_IMPORTED_MODULE_1__.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch__WEBPACK_IMPORTED_MODULE_0__.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === '**';\n            const absolute = p.isAbsolute();\n            if (absolute)\n                this.absolute.push(m);\n            else\n                this.relative.push(m);\n            if (children) {\n                if (absolute)\n                    this.absoluteChildren.push(m);\n                else\n                    this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || '.';\n        const relatives = `${relative}/`;\n        for (const m of this.relative) {\n            if (m.match(relative) || m.match(relatives))\n                return true;\n        }\n        for (const m of this.absolute) {\n            if (m.match(fullpath) || m.match(fullpaths))\n                return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + '/';\n        const relative = (p.relative() || '.') + '/';\n        for (const m of this.relativeChildren) {\n            if (m.match(relative))\n                return true;\n        }\n        for (const m of this.absoluteChildren) {\n            if (m.match(fullpath))\n                return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=ignore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pZ25vcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQWlFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQVM7QUFDaEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBTztBQUNqQywwQkFBMEIsZ0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvZXNtL2lnbm9yZS5qcz8zYjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGdpdmUgaXQgYSBwYXR0ZXJuLCBhbmQgaXQnbGwgYmUgYWJsZSB0byB0ZWxsIHlvdSBpZlxuLy8gYSBnaXZlbiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkLlxuLy8gSWdub3JpbmcgYSBwYXRoIGlnbm9yZXMgaXRzIGNoaWxkcmVuIGlmIHRoZSBwYXR0ZXJuIGVuZHMgaW4gLyoqXG4vLyBJZ25vcmVzIGFyZSBhbHdheXMgcGFyc2VkIGluIGRvdDp0cnVlIG1vZGVcbmltcG9ydCB7IE1pbmltYXRjaCB9IGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgeyBQYXR0ZXJuIH0gZnJvbSAnLi9wYXR0ZXJuLmpzJztcbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucGxhdGZvcm0gPT09ICdzdHJpbmcnKSA/XG4gICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ2xpbnV4Jztcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBwcm9jZXNzIGlnbm9yZWQgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGNsYXNzIElnbm9yZSB7XG4gICAgcmVsYXRpdmU7XG4gICAgcmVsYXRpdmVDaGlsZHJlbjtcbiAgICBhYnNvbHV0ZTtcbiAgICBhYnNvbHV0ZUNoaWxkcmVuO1xuICAgIHBsYXRmb3JtO1xuICAgIG1tb3B0cztcbiAgICBjb25zdHJ1Y3RvcihpZ25vcmVkLCB7IG5vYnJhY2UsIG5vY2FzZSwgbm9leHQsIG5vZ2xvYnN0YXIsIHBsYXRmb3JtID0gZGVmYXVsdFBsYXRmb3JtLCB9KSB7XG4gICAgICAgIHRoaXMucmVsYXRpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5tbW9wdHMgPSB7XG4gICAgICAgICAgICBkb3Q6IHRydWUsXG4gICAgICAgICAgICBub2JyYWNlLFxuICAgICAgICAgICAgbm9jYXNlLFxuICAgICAgICAgICAgbm9leHQsXG4gICAgICAgICAgICBub2dsb2JzdGFyLFxuICAgICAgICAgICAgb3B0aW1pemF0aW9uTGV2ZWw6IDIsXG4gICAgICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgICAgIG5vY29tbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIG5vbmVnYXRlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGlnbiBvZiBpZ25vcmVkKVxuICAgICAgICAgICAgdGhpcy5hZGQoaWduKTtcbiAgICB9XG4gICAgYWRkKGlnbikge1xuICAgICAgICAvLyB0aGlzIGlzIGEgbGl0dGxlIHdlaXJkLCBidXQgaXQgZ2l2ZXMgdXMgYSBjbGVhbiBzZXQgb2Ygb3B0aW1pemVkXG4gICAgICAgIC8vIG1pbmltYXRjaCBtYXRjaGVycywgd2l0aG91dCBnZXR0aW5nIHRyaXBwZWQgdXAgaWYgb25lIG9mIHRoZW1cbiAgICAgICAgLy8gZW5kcyBpbiAvKiogaW5zaWRlIGEgYnJhY2Ugc2VjdGlvbiwgYW5kIGl0J3Mgb25seSBpbmVmZmljaWVudCBhdFxuICAgICAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIHdhbGssIG5vdCBhbG9uZyBpdC5cbiAgICAgICAgLy8gSXQnZCBiZSBuaWNlIGlmIHRoZSBQYXR0ZXJuIGNsYXNzIGp1c3QgaGFkIGEgLnRlc3QoKSBtZXRob2QsIGJ1dFxuICAgICAgICAvLyBoYW5kbGluZyBnbG9ic3RhcnMgaXMgYSBiaXQgb2YgYSBwaXRhLCBhbmQgdGhhdCBjb2RlIGFscmVhZHkgbGl2ZXNcbiAgICAgICAgLy8gaW4gbWluaW1hdGNoIGFueXdheS5cbiAgICAgICAgLy8gQW5vdGhlciB3YXkgd291bGQgYmUgaWYgbWF5YmUgTWluaW1hdGNoIGNvdWxkIHRha2UgaXRzIHNldC9nbG9iUGFydHNcbiAgICAgICAgLy8gYXMgYW4gb3B0aW9uLCBhbmQgdGhlbiB3ZSBjb3VsZCBhdCBsZWFzdCBqdXN0IHVzZSBQYXR0ZXJuIHRvIHRlc3RcbiAgICAgICAgLy8gZm9yIGFic29sdXRlLW5lc3MuXG4gICAgICAgIC8vIFlldCBhbm90aGVyIHdheSwgTWluaW1hdGNoIGNvdWxkIHRha2UgYW4gYXJyYXkgb2YgZ2xvYiBzdHJpbmdzLCBhbmRcbiAgICAgICAgLy8gYSBjd2Qgb3B0aW9uLCBhbmQgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgICAgICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2goaWduLCB0aGlzLm1tb3B0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW0uc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtbS5zZXRbaV07XG4gICAgICAgICAgICBjb25zdCBnbG9iUGFydHMgPSBtbS5nbG9iUGFydHNbaV07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICghcGFyc2VkIHx8ICFnbG9iUGFydHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGF0dGVybiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0cmlwIG9mZiBsZWFkaW5nIC4vIHBvcnRpb25zXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvNTcwXG4gICAgICAgICAgICB3aGlsZSAocGFyc2VkWzBdID09PSAnLicgJiYgZ2xvYlBhcnRzWzBdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBnbG9iUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBhdHRlcm4ocGFyc2VkLCBnbG9iUGFydHMsIDAsIHRoaXMucGxhdGZvcm0pO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNaW5pbWF0Y2gocC5nbG9iU3RyaW5nKCksIHRoaXMubW1vcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2xvYlBhcnRzW2dsb2JQYXJ0cy5sZW5ndGggLSAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcC5pc0Fic29sdXRlKCk7XG4gICAgICAgICAgICBpZiAoYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZS5wdXNoKG0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmUucHVzaChtKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuLnB1c2gobSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4ucHVzaChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVkKHApIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSBwLmZ1bGxwYXRoKCk7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRocyA9IGAke2Z1bGxwYXRofS9gO1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IHAucmVsYXRpdmUoKSB8fCAnLic7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlcyA9IGAke3JlbGF0aXZlfS9gO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2gocmVsYXRpdmUpIHx8IG0ubWF0Y2gocmVsYXRpdmVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5hYnNvbHV0ZSkge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2goZnVsbHBhdGgpIHx8IG0ubWF0Y2goZnVsbHBhdGhzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoaWxkcmVuSWdub3JlZChwKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gcC5mdWxscGF0aCgpICsgJy8nO1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IChwLnJlbGF0aXZlKCkgfHwgJy4nKSArICcvJztcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMucmVsYXRpdmVDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2gocmVsYXRpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLmFic29sdXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKGZ1bGxwYXRoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWdub3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/ignore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/glob/dist/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Glob: () => (/* reexport safe */ _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob),\n/* harmony export */   Ignore: () => (/* reexport safe */ _ignore_js__WEBPACK_IMPORTED_MODULE_3__.Ignore),\n/* harmony export */   escape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.escape),\n/* harmony export */   glob: () => (/* binding */ glob),\n/* harmony export */   globIterate: () => (/* binding */ globIterate),\n/* harmony export */   globIterateSync: () => (/* binding */ globIterateSync),\n/* harmony export */   globStream: () => (/* binding */ globStream),\n/* harmony export */   globStreamSync: () => (/* binding */ globStreamSync),\n/* harmony export */   globSync: () => (/* binding */ globSync),\n/* harmony export */   hasMagic: () => (/* reexport safe */ _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic),\n/* harmony export */   iterate: () => (/* binding */ iterate),\n/* harmony export */   iterateSync: () => (/* binding */ iterateSync),\n/* harmony export */   stream: () => (/* binding */ stream),\n/* harmony export */   streamSync: () => (/* binding */ streamSync),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   unescape: () => (/* reexport safe */ minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n/* harmony import */ var _glob_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/esm/glob.js\");\n/* harmony import */ var _has_magic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/esm/has-magic.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/esm/ignore.js\");\n\n\n\n\n\n\n\nfunction globStreamSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nconst streamSync = globStreamSync;\nconst stream = Object.assign(globStream, { sync: globStreamSync });\nconst iterateSync = globIterateSync;\nconst iterate = Object.assign(globIterate, {\n    sync: globIterateSync,\n});\nconst sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync,\n});\nconst glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync,\n    globStream,\n    stream,\n    globStreamSync,\n    streamSync,\n    globIterate,\n    iterate,\n    globIterateSync,\n    iterateSync,\n    Glob: _glob_js__WEBPACK_IMPORTED_MODULE_1__.Glob,\n    hasMagic: _has_magic_js__WEBPACK_IMPORTED_MODULE_2__.hasMagic,\n    escape: minimatch__WEBPACK_IMPORTED_MODULE_0__.escape,\n    unescape: minimatch__WEBPACK_IMPORTED_MODULE_0__.unescape,\n});\nglob.glob = glob;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUNaO0FBQ1M7QUFDRztBQUNaO0FBQ1M7QUFDTDtBQUM5Qiw2Q0FBNkM7QUFDcEQsZUFBZSwwQ0FBSTtBQUNuQjtBQUNPLHlDQUF5QztBQUNoRCxlQUFlLDBDQUFJO0FBQ25CO0FBQ08sdUNBQXVDO0FBQzlDLGVBQWUsMENBQUk7QUFDbkI7QUFDQSwwQ0FBMEM7QUFDMUMsZUFBZSwwQ0FBSTtBQUNuQjtBQUNPLDhDQUE4QztBQUNyRCxlQUFlLDBDQUFJO0FBQ25CO0FBQ08sMENBQTBDO0FBQ2pELGVBQWUsMENBQUk7QUFDbkI7QUFDQTtBQUNPO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ1A7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZO0FBQ1osVUFBVTtBQUNWLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9pbmRleC5qcz84YjI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVzY2FwZSwgdW5lc2NhcGUgfSBmcm9tICdtaW5pbWF0Y2gnO1xuaW1wb3J0IHsgR2xvYiB9IGZyb20gJy4vZ2xvYi5qcyc7XG5pbXBvcnQgeyBoYXNNYWdpYyB9IGZyb20gJy4vaGFzLW1hZ2ljLmpzJztcbmV4cG9ydCB7IGVzY2FwZSwgdW5lc2NhcGUgfSBmcm9tICdtaW5pbWF0Y2gnO1xuZXhwb3J0IHsgR2xvYiB9IGZyb20gJy4vZ2xvYi5qcyc7XG5leHBvcnQgeyBoYXNNYWdpYyB9IGZyb20gJy4vaGFzLW1hZ2ljLmpzJztcbmV4cG9ydCB7IElnbm9yZSB9IGZyb20gJy4vaWdub3JlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnbG9iU3RyZWFtU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucykuc3RyZWFtU3luYygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JTdHJlYW0ocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLnN0cmVhbSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsb2JTeW5jKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKS53YWxrU3luYygpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2xvYl8ocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGsoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbG9iSXRlcmF0ZVN5bmMocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGVTeW5jKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xvYkl0ZXJhdGUocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGUoKTtcbn1cbi8vIGFsaWFzZXM6IGdsb2Iuc3luYy5zdHJlYW0oKSBnbG9iLnN0cmVhbS5zeW5jKCkgZ2xvYi5zeW5jKCkgZXRjXG5leHBvcnQgY29uc3Qgc3RyZWFtU3luYyA9IGdsb2JTdHJlYW1TeW5jO1xuZXhwb3J0IGNvbnN0IHN0cmVhbSA9IE9iamVjdC5hc3NpZ24oZ2xvYlN0cmVhbSwgeyBzeW5jOiBnbG9iU3RyZWFtU3luYyB9KTtcbmV4cG9ydCBjb25zdCBpdGVyYXRlU3luYyA9IGdsb2JJdGVyYXRlU3luYztcbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gT2JqZWN0LmFzc2lnbihnbG9iSXRlcmF0ZSwge1xuICAgIHN5bmM6IGdsb2JJdGVyYXRlU3luYyxcbn0pO1xuZXhwb3J0IGNvbnN0IHN5bmMgPSBPYmplY3QuYXNzaWduKGdsb2JTeW5jLCB7XG4gICAgc3RyZWFtOiBnbG9iU3RyZWFtU3luYyxcbiAgICBpdGVyYXRlOiBnbG9iSXRlcmF0ZVN5bmMsXG59KTtcbmV4cG9ydCBjb25zdCBnbG9iID0gT2JqZWN0LmFzc2lnbihnbG9iXywge1xuICAgIGdsb2I6IGdsb2JfLFxuICAgIGdsb2JTeW5jLFxuICAgIHN5bmMsXG4gICAgZ2xvYlN0cmVhbSxcbiAgICBzdHJlYW0sXG4gICAgZ2xvYlN0cmVhbVN5bmMsXG4gICAgc3RyZWFtU3luYyxcbiAgICBnbG9iSXRlcmF0ZSxcbiAgICBpdGVyYXRlLFxuICAgIGdsb2JJdGVyYXRlU3luYyxcbiAgICBpdGVyYXRlU3luYyxcbiAgICBHbG9iLFxuICAgIGhhc01hZ2ljLFxuICAgIGVzY2FwZSxcbiAgICB1bmVzY2FwZSxcbn0pO1xuZ2xvYi5nbG9iID0gZ2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/glob/dist/esm/pattern.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Pattern: () => (/* binding */ Pattern)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n// this is just a very light wrapper around 2 arrays with an offset index\n\nconst isPatternList = (pl) => pl.length >= 1;\nconst isGlobList = (gl) => gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nclass Pattern {\n    #patternList;\n    #globList;\n    #index;\n    length;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar = true;\n    constructor(patternList, globList, index, platform) {\n        if (!isPatternList(patternList)) {\n            throw new TypeError('empty pattern list');\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError('empty glob list');\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError('mismatched pattern list and glob list lengths');\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError('index out of range');\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [p0, p1, p2, p3, ''].join('/');\n                const g = [g0, g1, g2, g3, ''].join('/');\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n            else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === '') {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + '/';\n                const g = g1 + '/';\n                this.#patternList = [p, ...prest];\n                this.#globList = [g, ...grest];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */\n    pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */\n    isString() {\n        return typeof this.#patternList[this.#index] === 'string';\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */\n    isGlobstar() {\n        return this.#patternList[this.#index] === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */\n    isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */\n    globString() {\n        return (this.#globString =\n            this.#globString ||\n                (this.#index === 0 ?\n                    this.isAbsolute() ?\n                        this.#globList[0] + this.#globList.slice(1).join('/')\n                        : this.#globList.join('/')\n                    : this.#globList.slice(this.#index).join('/')));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */\n    hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */\n    rest() {\n        if (this.#rest !== undefined)\n            return this.#rest;\n        if (!this.hasMore())\n            return (this.#rest = null);\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */\n    isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ?\n            this.#isUNC\n            : (this.#isUNC =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    pl[0] === '' &&\n                    pl[1] === '' &&\n                    typeof pl[2] === 'string' &&\n                    !!pl[2] &&\n                    typeof pl[3] === 'string' &&\n                    !!pl[3]);\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */\n    isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ?\n            this.#isDrive\n            : (this.#isDrive =\n                this.#platform === 'win32' &&\n                    this.#index === 0 &&\n                    this.length > 1 &&\n                    typeof pl[0] === 'string' &&\n                    /^[a-z]:$/i.test(pl[0]));\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */\n    isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ?\n            this.#isAbsolute\n            : (this.#isAbsolute =\n                (pl[0] === '' && pl.length > 1) ||\n                    this.isDrive() ||\n                    this.isUNC());\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */\n    root() {\n        const p = this.#patternList[0];\n        return (typeof p === 'string' && this.isAbsolute() && this.#index === 0) ?\n            p\n            : '';\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */\n    checkFollowGlobstar() {\n        return !(this.#index === 0 ||\n            !this.isGlobstar() ||\n            !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */\n    markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n            return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\n//# sourceMappingURL=pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELCtDQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vcGF0dGVybi5qcz8zMDM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgaXMganVzdCBhIHZlcnkgbGlnaHQgd3JhcHBlciBhcm91bmQgMiBhcnJheXMgd2l0aCBhbiBvZmZzZXQgaW5kZXhcbmltcG9ydCB7IEdMT0JTVEFSIH0gZnJvbSAnbWluaW1hdGNoJztcbmNvbnN0IGlzUGF0dGVybkxpc3QgPSAocGwpID0+IHBsLmxlbmd0aCA+PSAxO1xuY29uc3QgaXNHbG9iTGlzdCA9IChnbCkgPT4gZ2wubGVuZ3RoID49IDE7XG4vKipcbiAqIEFuIGltbXV0YWJsZS1pc2ggdmlldyBvbiBhbiBhcnJheSBvZiBnbG9iIHBhcnRzIGFuZCB0aGVpciBwYXJzZWRcbiAqIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBhdHRlcm4ge1xuICAgICNwYXR0ZXJuTGlzdDtcbiAgICAjZ2xvYkxpc3Q7XG4gICAgI2luZGV4O1xuICAgIGxlbmd0aDtcbiAgICAjcGxhdGZvcm07XG4gICAgI3Jlc3Q7XG4gICAgI2dsb2JTdHJpbmc7XG4gICAgI2lzRHJpdmU7XG4gICAgI2lzVU5DO1xuICAgICNpc0Fic29sdXRlO1xuICAgICNmb2xsb3dHbG9ic3RhciA9IHRydWU7XG4gICAgY29uc3RydWN0b3IocGF0dGVybkxpc3QsIGdsb2JMaXN0LCBpbmRleCwgcGxhdGZvcm0pIHtcbiAgICAgICAgaWYgKCFpc1BhdHRlcm5MaXN0KHBhdHRlcm5MaXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW1wdHkgcGF0dGVybiBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0dsb2JMaXN0KGdsb2JMaXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW1wdHkgZ2xvYiBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2JMaXN0Lmxlbmd0aCAhPT0gcGF0dGVybkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNtYXRjaGVkIHBhdHRlcm4gbGlzdCBhbmQgZ2xvYiBsaXN0IGxlbmd0aHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IHBhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBwYXR0ZXJuTGlzdDtcbiAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBnbG9iTGlzdDtcbiAgICAgICAgdGhpcy4jaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy4jcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHJvb3QgZW50cmllcyBvZiBhYnNvbHV0ZSBwYXR0ZXJucyBvbiBpbml0aWFsIGNyZWF0aW9uLlxuICAgICAgICBpZiAodGhpcy4jaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGM6ID0+IFsnYzovJ11cbiAgICAgICAgICAgIC8vIEM6LyA9PiBbJ0M6LyddXG4gICAgICAgICAgICAvLyBDOi94ID0+IFsnQzovJywgJ3gnXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlID0+IFsnLy9ob3N0L3NoYXJlLyddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUvID0+IFsnLy9ob3N0L3NoYXJlLyddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUveCA9PiBbJy8vaG9zdC9zaGFyZS8nLCAneCddXG4gICAgICAgICAgICAvLyAvZXRjID0+IFsnLycsICdldGMnXVxuICAgICAgICAgICAgLy8gLyA9PiBbJy8nXVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNVTkMoKSkge1xuICAgICAgICAgICAgICAgIC8vICcnIC8gJycgLyAnaG9zdCcgLyAnc2hhcmUnXG4gICAgICAgICAgICAgICAgY29uc3QgW3AwLCBwMSwgcDIsIHAzLCAuLi5wcmVzdF0gPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBbZzAsIGcxLCBnMiwgZzMsIC4uLmdyZXN0XSA9IHRoaXMuI2dsb2JMaXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcmVzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kcyBpbiAvXG4gICAgICAgICAgICAgICAgICAgIHByZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGdyZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBbcDAsIHAxLCBwMiwgcDMsICcnXS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IFtnMCwgZzEsIGcyLCBnMywgJyddLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IFtwLCAuLi5wcmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBbZywgLi4uZ3Jlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy4jcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0RyaXZlKCkgfHwgdGhpcy5pc0Fic29sdXRlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcDEsIC4uLnByZXN0XSA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtnMSwgLi4uZ3Jlc3RdID0gdGhpcy4jZ2xvYkxpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByZXN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmRzIGluIC9cbiAgICAgICAgICAgICAgICAgICAgcHJlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3Jlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHAxICsgJy8nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBnMSArICcvJztcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IFtwLCAuLi5wcmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBbZywgLi4uZ3Jlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy4jcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgcGFyc2VkIGxpc3Qgb2YgcGF0dGVybnNcbiAgICAgKi9cbiAgICBwYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIG9mIGlmIHBhdHRlcm4oKSByZXR1cm5zIGEgc3RyaW5nXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBvZiBpZiBwYXR0ZXJuKCkgcmV0dXJucyBHTE9CU1RBUlxuICAgICAqL1xuICAgIGlzR2xvYnN0YXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gPT09IEdMT0JTVEFSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHBhdHRlcm4oKSByZXR1cm5zIGEgcmVnZXhwXG4gICAgICovXG4gICAgaXNSZWdFeHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSAvLWpvaW5lZCBzZXQgb2YgZ2xvYiBwYXJ0cyB0aGF0IG1ha2UgdXAgdGhpcyBwYXR0ZXJuXG4gICAgICovXG4gICAgZ2xvYlN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNnbG9iU3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuI2dsb2JTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICAodGhpcy4jaW5kZXggPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQWJzb2x1dGUoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdFswXSArIHRoaXMuI2dsb2JMaXN0LnNsaWNlKDEpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNnbG9iTGlzdC5qb2luKCcvJylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNnbG9iTGlzdC5zbGljZSh0aGlzLiNpbmRleCkuam9pbignLycpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGF0dGVybiBwYXJ0cyBhZnRlciB0aGlzIG9uZVxuICAgICAqL1xuICAgIGhhc01vcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IHRoaXMuI2luZGV4ICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXIgdGhpcyBwYXJ0LCBvciBudWxsIGlmIHRoaXMgaXMgdGhlIGVuZFxuICAgICAqL1xuICAgIHJlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZXN0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmhhc01vcmUoKSlcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVzdCA9IG51bGwpO1xuICAgICAgICB0aGlzLiNyZXN0ID0gbmV3IFBhdHRlcm4odGhpcy4jcGF0dGVybkxpc3QsIHRoaXMuI2dsb2JMaXN0LCB0aGlzLiNpbmRleCArIDEsIHRoaXMuI3BsYXRmb3JtKTtcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNBYnNvbHV0ZSA9IHRoaXMuI2lzQWJzb2x1dGU7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzVU5DID0gdGhpcy4jaXNVTkM7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzRHJpdmUgPSB0aGlzLiNpc0RyaXZlO1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgcGF0dGVybiByZXByZXNlbnRzIGEgLy91bmMvcGF0aC8gb24gd2luZG93c1xuICAgICAqL1xuICAgIGlzVU5DKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNVTkMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc1VOQ1xuICAgICAgICAgICAgOiAodGhpcy4jaXNVTkMgPVxuICAgICAgICAgICAgICAgIHRoaXMuI3BsYXRmb3JtID09PSAnd2luMzInICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2luZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHBsWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBwbFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzJdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAhIXBsWzJdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgISFwbFszXSk7XG4gICAgfVxuICAgIC8vIHBhdHRlcm4gbGlrZSBDOi8uLi5cbiAgICAvLyBzcGxpdCA9IFsnQzonLCAuLi5dXG4gICAgLy8gWFhYOiB3b3VsZCBiZSBuaWNlIHRvIGhhbmRsZSBwYXR0ZXJucyBsaWtlIGBjOipgIHRvIHRlc3QgdGhlIGN3ZFxuICAgIC8vIGluIGM6IGZvciAqLCBidXQgSSBkb24ndCBrbm93IG9mIGEgd2F5IHRvIGV2ZW4gZmlndXJlIG91dCB3aGF0IHRoYXRcbiAgICAvLyBjd2QgaXMgd2l0aG91dCBhY3R1YWxseSBjaGRpcidpbmcgaW50byBpdD9cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIGEgZHJpdmUgbGV0dGVyIG9uIFdpbmRvd3NcbiAgICAgKi9cbiAgICBpc0RyaXZlKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNEcml2ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzRHJpdmVcbiAgICAgICAgICAgIDogKHRoaXMuI2lzRHJpdmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuI3BsYXRmb3JtID09PSAnd2luMzInICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2luZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QocGxbMF0pKTtcbiAgICB9XG4gICAgLy8gcGF0dGVybiA9ICcvJyBvciAnLy4uLicgb3IgJy94Ly4uLidcbiAgICAvLyBzcGxpdCA9IFsnJywgJyddIG9yIFsnJywgLi4uXSBvciBbJycsICd4JywgLi4uXVxuICAgIC8vIERyaXZlIGFuZCBVTkMgYm90aCBjb25zaWRlcmVkIGFic29sdXRlIG9uIHdpbmRvd3NcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwYXR0ZXJuIGlzIHJvb3RlZCBvbiBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICovXG4gICAgaXNBYnNvbHV0ZSgpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzQWJzb2x1dGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc0Fic29sdXRlXG4gICAgICAgICAgICA6ICh0aGlzLiNpc0Fic29sdXRlID1cbiAgICAgICAgICAgICAgICAocGxbMF0gPT09ICcnICYmIHBsLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcml2ZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNVTkMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbnN1bWUgdGhlIHJvb3Qgb2YgdGhlIHBhdHRlcm4sIGFuZCByZXR1cm4gaXRcbiAgICAgKi9cbiAgICByb290KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy4jcGF0dGVybkxpc3RbMF07XG4gICAgICAgIHJldHVybiAodHlwZW9mIHAgPT09ICdzdHJpbmcnICYmIHRoaXMuaXNBYnNvbHV0ZSgpICYmIHRoaXMuI2luZGV4ID09PSAwKSA/XG4gICAgICAgICAgICBwXG4gICAgICAgICAgICA6ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgZ2xvYnN0YXIgcGF0dGVybiBpcyBhbGxvd2VkIHRvIGZvbGxvd1xuICAgICAqIGEgc3ltYm9saWMgbGluay5cbiAgICAgKi9cbiAgICBjaGVja0ZvbGxvd0dsb2JzdGFyKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLiNpbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgIXRoaXMuaXNHbG9ic3RhcigpIHx8XG4gICAgICAgICAgICAhdGhpcy4jZm9sbG93R2xvYnN0YXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIHRoYXQgdGhlIGN1cnJlbnQgZ2xvYnN0YXIgcGF0dGVybiBpcyBmb2xsb3dpbmcgYSBzeW1ib2xpYyBsaW5rXG4gICAgICovXG4gICAgbWFya0ZvbGxvd0dsb2JzdGFyKCkge1xuICAgICAgICBpZiAodGhpcy4jaW5kZXggPT09IDAgfHwgIXRoaXMuaXNHbG9ic3RhcigpIHx8ICF0aGlzLiNmb2xsb3dHbG9ic3RhcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4jZm9sbG93R2xvYnN0YXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/processor.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/esm/processor.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HasWalkedCache: () => (/* binding */ HasWalkedCache),\n/* harmony export */   MatchRecord: () => (/* binding */ MatchRecord),\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   SubWalks: () => (/* binding */ SubWalks)\n/* harmony export */ });\n/* harmony import */ var minimatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/minimatch/dist/esm/index.js\");\n// synchronous utility for filtering entries and calculating subwalks\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache =\n            hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined ?\n                    this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === '..' || p === '' || p === '.';\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            }\n            else if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch__WEBPACK_IMPORTED_MODULE_0__.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS9wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vcHJvY2Vzc29yLmpzPzQxODciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3luY2hyb25vdXMgdXRpbGl0eSBmb3IgZmlsdGVyaW5nIGVudHJpZXMgYW5kIGNhbGN1bGF0aW5nIHN1YndhbGtzXG5pbXBvcnQgeyBHTE9CU1RBUiB9IGZyb20gJ21pbmltYXRjaCc7XG4vKipcbiAqIEEgY2FjaGUgb2Ygd2hpY2ggcGF0dGVybnMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBmb3IgYSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNXYWxrZWRDYWNoZSB7XG4gICAgc3RvcmU7XG4gICAgY29uc3RydWN0b3Ioc3RvcmUgPSBuZXcgTWFwKCkpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEhhc1dhbGtlZENhY2hlKG5ldyBNYXAodGhpcy5zdG9yZSkpO1xuICAgIH1cbiAgICBoYXNXYWxrZWQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldCh0YXJnZXQuZnVsbHBhdGgoKSk/LmhhcyhwYXR0ZXJuLmdsb2JTdHJpbmcoKSk7XG4gICAgfVxuICAgIHN0b3JlV2Fsa2VkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRhcmdldC5mdWxscGF0aCgpO1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLnN0b3JlLmdldChmdWxscGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpXG4gICAgICAgICAgICBjYWNoZWQuYWRkKHBhdHRlcm4uZ2xvYlN0cmluZygpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdG9yZS5zZXQoZnVsbHBhdGgsIG5ldyBTZXQoW3BhdHRlcm4uZ2xvYlN0cmluZygpXSkpO1xuICAgIH1cbn1cbi8qKlxuICogQSByZWNvcmQgb2Ygd2hpY2ggcGF0aHMgaGF2ZSBiZWVuIG1hdGNoZWQgaW4gYSBnaXZlbiB3YWxrIHN0ZXAsXG4gKiBhbmQgd2hldGhlciB0aGV5IG9ubHkgYXJlIGNvbnNpZGVyZWQgYSBtYXRjaCBpZiB0aGV5IGFyZSBhIGRpcmVjdG9yeSxcbiAqIGFuZCB3aGV0aGVyIHRoZWlyIGFic29sdXRlIG9yIHJlbGF0aXZlIHBhdGggc2hvdWxkIGJlIHJldHVybmVkLlxuICovXG5leHBvcnQgY2xhc3MgTWF0Y2hSZWNvcmQge1xuICAgIHN0b3JlID0gbmV3IE1hcCgpO1xuICAgIGFkZCh0YXJnZXQsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBuID0gKGFic29sdXRlID8gMiA6IDApIHwgKGlmRGlyID8gMSA6IDApO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zdG9yZS5zZXQodGFyZ2V0LCBjdXJyZW50ID09PSB1bmRlZmluZWQgPyBuIDogbiAmIGN1cnJlbnQpO1xuICAgIH1cbiAgICAvLyBtYXRjaCwgYWJzb2x1dGUsIGlmZGlyXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmVudHJpZXMoKV0ubWFwKChbcGF0aCwgbl0pID0+IFtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAhIShuICYgMiksXG4gICAgICAgICAgICAhIShuICYgMSksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHBhdHRlcm5zIHRoYXQgbXVzdCBiZSBwcm9jZXNzZWQgaW4gYSBzdWJzZXF1ZW50IHN0ZXBcbiAqIGZvciBhIGdpdmVuIHBhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJXYWxrcyB7XG4gICAgc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgYWRkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICBpZiAoIXRhcmdldC5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHN1YnMpIHtcbiAgICAgICAgICAgIGlmICghc3Vicy5maW5kKHAgPT4gcC5nbG9iU3RyaW5nKCkgPT09IHBhdHRlcm4uZ2xvYlN0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHN1YnMucHVzaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnNldCh0YXJnZXQsIFtwYXR0ZXJuXSk7XG4gICAgfVxuICAgIGdldCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXN1YnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGluZyB0byB3YWxrIHVua25vd24gcGF0aCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiBzdWJzO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzKCkubWFwKGsgPT4gW2ssIHRoaXMuc3RvcmUuZ2V0KGspXSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zdG9yZS5rZXlzKCldLmZpbHRlcih0ID0+IHQuY2FuUmVhZGRpcigpKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBjbGFzcyB0aGF0IHByb2Nlc3NlcyBwYXR0ZXJucyBmb3IgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEhhbmRsZXMgY2hpbGQgZW50cnkgZmlsdGVyaW5nLCBhbmQgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHBhdGgnc1xuICogZGlyZWN0b3J5IGNvbnRlbnRzIG11c3QgYmUgcmVhZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb2Nlc3NvciB7XG4gICAgaGFzV2Fsa2VkQ2FjaGU7XG4gICAgbWF0Y2hlcyA9IG5ldyBNYXRjaFJlY29yZCgpO1xuICAgIHN1YndhbGtzID0gbmV3IFN1YldhbGtzKCk7XG4gICAgcGF0dGVybnM7XG4gICAgZm9sbG93O1xuICAgIGRvdDtcbiAgICBvcHRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdHMsIGhhc1dhbGtlZENhY2hlKSB7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuZm9sbG93ID0gISFvcHRzLmZvbGxvdztcbiAgICAgICAgdGhpcy5kb3QgPSAhIW9wdHMuZG90O1xuICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlID1cbiAgICAgICAgICAgIGhhc1dhbGtlZENhY2hlID8gaGFzV2Fsa2VkQ2FjaGUuY29weSgpIDogbmV3IEhhc1dhbGtlZENhY2hlKCk7XG4gICAgfVxuICAgIHByb2Nlc3NQYXR0ZXJucyh0YXJnZXQsIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBwYXR0ZXJucztcbiAgICAgICAgY29uc3QgcHJvY2Vzc2luZ1NldCA9IHBhdHRlcm5zLm1hcChwID0+IFt0YXJnZXQsIHBdKTtcbiAgICAgICAgLy8gbWFwIG9mIHBhdGhzIHRvIHRoZSBtYWdpYy1zdGFydGluZyBzdWJ3YWxrcyB0aGV5IG5lZWQgdG8gd2Fsa1xuICAgICAgICAvLyBmaXJzdCBpdGVtIGluIHBhdHRlcm5zIGlzIHRoZSBmaWx0ZXJcbiAgICAgICAgZm9yIChsZXQgW3QsIHBhdHRlcm5dIG9mIHByb2Nlc3NpbmdTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUuc3RvcmVXYWxrZWQodCwgcGF0dGVybik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gcGF0dGVybi5yb290KCk7XG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZSA9IHBhdHRlcm4uaXNBYnNvbHV0ZSgpICYmIHRoaXMub3B0cy5hYnNvbHV0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAvLyBzdGFydCBhYnNvbHV0ZSBwYXR0ZXJucyBhdCByb290XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHQgPSB0LnJlc29sdmUocm9vdCA9PT0gJy8nICYmIHRoaXMub3B0cy5yb290ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdHMucm9vdFxuICAgICAgICAgICAgICAgICAgICA6IHJvb3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwYXR0ZXJuLnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQuaXNFTk9FTlQoKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgbGV0IHJlc3Q7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiAocCA9IHBhdHRlcm4ucGF0dGVybigpKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAocmVzdCA9IHBhdHRlcm4ucmVzdCgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB0LnJlc29sdmUocCk7XG4gICAgICAgICAgICAgICAgdCA9IGM7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcGF0dGVybi5wYXR0ZXJuKCk7XG4gICAgICAgICAgICByZXN0ID0gcGF0dGVybi5yZXN0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1dhbGtlZENhY2hlLmhhc1dhbGtlZCh0LCBwYXR0ZXJuKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZS5zdG9yZVdhbGtlZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdyB3ZSBoYXZlIGVpdGhlciBhIGZpbmFsIHN0cmluZyBmb3IgYSBrbm93biBlbnRyeSxcbiAgICAgICAgICAgIC8vIG1vcmUgc3RyaW5ncyBmb3IgYW4gdW5rbm93biBlbnRyeSxcbiAgICAgICAgICAgIC8vIG9yIGEgcGF0dGVybiBzdGFydGluZyB3aXRoIG1hZ2ljLCBtb3VudGVkIG9uIHQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBub3QgYmUgZmluYWwgZW50cnksIG90aGVyd2lzZSB3ZSB3b3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gY29uY2F0ZW5hdGVkIGl0IGVhcmxpZXIuXG4gICAgICAgICAgICAgICAgY29uc3QgaWZEaXIgPSBwID09PSAnLi4nIHx8IHAgPT09ICcnIHx8IHAgPT09ICcuJztcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQucmVzb2x2ZShwKSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gcmVzdCwgbWF0Y2ggYW5kIHN1YndhbGsgcGF0dGVyblxuICAgICAgICAgICAgICAgIC8vIGlmIHJlc3QsIHByb2Nlc3MgcmVzdCBhbmQgc3Vid2FsayBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhIHN5bWxpbmssIGJ1dCB3ZSBkaWRuJ3QgZ2V0IGhlcmUgYnkgd2F5IG9mIGFcbiAgICAgICAgICAgICAgICAvLyBnbG9ic3RhciBtYXRjaCAobWVhbmluZyBpdCdzIHRoZSBmaXJzdCB0aW1lIFRISVMgZ2xvYnN0YXJcbiAgICAgICAgICAgICAgICAvLyBoYXMgdHJhdmVyc2VkIGEgc3ltbGluayksIHRoZW4gd2UgZm9sbG93IGl0LiBPdGhlcndpc2UsIHN0b3AuXG4gICAgICAgICAgICAgICAgaWYgKCF0LmlzU3ltYm9saWNMaW5rKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2xsb3cgfHxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5jaGVja0ZvbGxvd0dsb2JzdGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQodCwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJwID0gcmVzdD8ucGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJyZXN0ID0gcmVzdD8ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdCB8fCAoKHJwID09PSAnJyB8fCBycCA9PT0gJy4nKSAmJiAhcnJlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgSEFTIHRvIGJlIGEgZGlyIGlmIGl0IGVuZHMgaW4gKiovIG9yICoqLy5cbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGVuZGluZyBpbiAqKiB3aWxsIG1hdGNoIGZpbGVzIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodCwgYWJzb2x1dGUsIHJwID09PSAnJyB8fCBycCA9PT0gJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3b3VsZCBtZWFuIHlvdSdyZSBtYXRjaGluZyAqKi8uLiBhdCB0aGUgZnMgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBubyB0aGFua3MsIEknbSBub3QgZ29ubmEgdGVzdCB0aGF0IHNwZWNpZmljIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRwID0gdC5wYXJlbnQgfHwgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJyZXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodHAsIGFic29sdXRlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc1dhbGtlZENhY2hlLmhhc1dhbGtlZCh0cCwgcnJlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQodHAsIHJyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZCh0LCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3Vid2Fsa1RhcmdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YndhbGtzLmtleXMoKTtcbiAgICB9XG4gICAgY2hpbGQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvY2Vzc29yKHRoaXMub3B0cywgdGhpcy5oYXNXYWxrZWRDYWNoZSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBhIG5ldyBQcm9jZXNzb3IgY29udGFpbmluZyB0aGUgc3Vid2Fsa3MgZm9yIGVhY2hcbiAgICAvLyBjaGlsZCBlbnRyeSwgYW5kIGEgc2V0IG9mIG1hdGNoZXMsIGFuZFxuICAgIC8vIGEgaGFzV2Fsa2VkQ2FjaGUgdGhhdCdzIGEgY29weSBvZiB0aGlzIG9uZVxuICAgIC8vIHRoZW4gd2UncmUgZ29pbmcgdG8gY2FsbFxuICAgIGZpbHRlckVudHJpZXMocGFyZW50LCBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5zID0gdGhpcy5zdWJ3YWxrcy5nZXQocGFyZW50KTtcbiAgICAgICAgLy8gcHV0IG1hdGNoZXMgYW5kIGVudHJ5IHdhbGtzIGludG8gdGhlIHJlc3VsdHMgcHJvY2Vzc29yXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLmNoaWxkKCk7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhYnNvbHV0ZSA9IHBhdHRlcm4uaXNBYnNvbHV0ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXR0ZXJuLnBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gcGF0dGVybi5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdEdsb2JzdGFyKGUsIHBhdHRlcm4sIHJlc3QsIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RSZWdFeHAoZSwgcCwgcmVzdCwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0U3RyaW5nKGUsIHAsIHJlc3QsIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHRlc3RHbG9ic3RhcihlLCBwYXR0ZXJuLCByZXN0LCBhYnNvbHV0ZSkge1xuICAgICAgICBpZiAodGhpcy5kb3QgfHwgIWUubmFtZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgIGlmICghcGF0dGVybi5oYXNNb3JlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBpbiBmb2xsb3cgbW9kZSBvciBpdCdzIG5vdCBhIHN5bWxpbmssIGp1c3Qga2VlcFxuICAgICAgICAgICAgICAgIC8vIHRlc3RpbmcgdGhlIHNhbWUgcGF0dGVybi4gSWYgdGhlcmUncyBtb3JlIGFmdGVyIHRoZSBnbG9ic3RhcixcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoaXMgc3ltbGluayBjb25zdW1lcyB0aGUgZ2xvYnN0YXIuIElmIG5vdCwgdGhlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBmb2xsb3cgYXQgbW9zdCBPTkUgc3ltbGluayBhbG9uZyB0aGUgd2F5LCBzbyB3ZSBtYXJrIGl0LCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGFsc28gY2hlY2tzIHRvIGVuc3VyZSB0aGF0IGl0IHdhc24ndCBhbHJlYWR5IG1hcmtlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mb2xsb3cgfHwgIWUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ICYmIHBhdHRlcm4uY2hlY2tGb2xsb3dHbG9ic3RhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXR0ZXJuLm1hcmtGb2xsb3dHbG9ic3RhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgTkVYVCB0aGluZyBtYXRjaGVzIHRoaXMgZW50cnksIHRoZW4gYWxzbyBhZGRcbiAgICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBycCA9IHJlc3QucGF0dGVybigpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBycCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvLyBkb3RzIGFuZCBlbXB0eSB3ZXJlIGhhbmRsZWQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIHJwICE9PSAnLi4nICYmXG4gICAgICAgICAgICAgICAgcnAgIT09ICcnICYmXG4gICAgICAgICAgICAgICAgcnAgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdFN0cmluZyhlLCBycCwgcmVzdC5yZXN0KCksIGFic29sdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJwID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgY29uc3QgZXAgPSBlLnBhcmVudCB8fCBlO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZXAsIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RSZWdFeHAoZSwgcnAsIHJlc3QucmVzdCgpLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGVzdFJlZ0V4cChlLCBwLCByZXN0LCBhYnNvbHV0ZSkge1xuICAgICAgICBpZiAoIXAudGVzdChlLm5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRlc3RTdHJpbmcoZSwgcCwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbj9cbiAgICAgICAgaWYgKCFlLmlzTmFtZWQocCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/esm/walker.js":
/*!**********************************************!*\
  !*** ./node_modules/glob/dist/esm/walker.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobStream: () => (/* binding */ GlobStream),\n/* harmony export */   GlobUtil: () => (/* binding */ GlobUtil),\n/* harmony export */   GlobWalker: () => (/* binding */ GlobWalker)\n/* harmony export */ });\n/* harmony import */ var minipass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/esm/index.js\");\n/* harmony import */ var _ignore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/esm/ignore.js\");\n/* harmony import */ var _processor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/glob/dist/esm/processor.js\");\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\n\n\n\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore([ignore], opts)\n    : Array.isArray(ignore) ? new _ignore_js__WEBPACK_IMPORTED_MODULE_1__.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    includeChildMatches;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches &&\n                typeof this.#ignore.add !== 'function') {\n                const m = 'cannot ignore child matches, ignore lacks add() method.';\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */\n            if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n            /* c8 ignore stop */\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return (e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            (!this.opts.nodir ||\n                !this.opts.follow ||\n                !e.isSymbolicLink() ||\n                !e.realpathCached()?.isDirectory()) &&\n            !this.#ignored(e)) ?\n            e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n                '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new _processor_js__WEBPACK_IMPORTED_MODULE_2__.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nclass GlobWalker extends GlobUtil {\n    matches = new Set();\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass__WEBPACK_IMPORTED_MODULE_0__.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\n//# sourceMappingURL=walker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2VzbS93YWxrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDQztBQUNNO0FBQzNDLHNFQUFzRSw4Q0FBTTtBQUM1RSxrQ0FBa0MsOENBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvREFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0RBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQVE7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9lc20vd2Fsa2VyLmpzPzQwMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaW5nbGUtdXNlIHV0aWxpdHkgY2xhc3NlcyB0byBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIHtAbGluayBHbG9ifVxuICogbWV0aG9kcy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IE1pbmlwYXNzIH0gZnJvbSAnbWluaXBhc3MnO1xuaW1wb3J0IHsgSWdub3JlIH0gZnJvbSAnLi9pZ25vcmUuanMnO1xuaW1wb3J0IHsgUHJvY2Vzc29yIH0gZnJvbSAnLi9wcm9jZXNzb3IuanMnO1xuY29uc3QgbWFrZUlnbm9yZSA9IChpZ25vcmUsIG9wdHMpID0+IHR5cGVvZiBpZ25vcmUgPT09ICdzdHJpbmcnID8gbmV3IElnbm9yZShbaWdub3JlXSwgb3B0cylcbiAgICA6IEFycmF5LmlzQXJyYXkoaWdub3JlKSA/IG5ldyBJZ25vcmUoaWdub3JlLCBvcHRzKVxuICAgICAgICA6IGlnbm9yZTtcbi8qKlxuICogYmFzaWMgd2Fsa2luZyB1dGlsaXRpZXMgdGhhdCBhbGwgdGhlIGdsb2Igd2Fsa2VyIHR5cGVzIHVzZVxuICovXG5leHBvcnQgY2xhc3MgR2xvYlV0aWwge1xuICAgIHBhdGg7XG4gICAgcGF0dGVybnM7XG4gICAgb3B0cztcbiAgICBzZWVuID0gbmV3IFNldCgpO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAjb25SZXN1bWUgPSBbXTtcbiAgICAjaWdub3JlO1xuICAgICNzZXA7XG4gICAgc2lnbmFsO1xuICAgIG1heERlcHRoO1xuICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM7XG4gICAgY29uc3RydWN0b3IocGF0dGVybnMsIHBhdGgsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLiNzZXAgPSAhb3B0cy5wb3NpeCAmJiBvcHRzLnBsYXRmb3JtID09PSAnd2luMzInID8gJ1xcXFwnIDogJy8nO1xuICAgICAgICB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMgPSBvcHRzLmluY2x1ZGVDaGlsZE1hdGNoZXMgIT09IGZhbHNlO1xuICAgICAgICBpZiAob3B0cy5pZ25vcmUgfHwgIXRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy4jaWdub3JlID0gbWFrZUlnbm9yZShvcHRzLmlnbm9yZSA/PyBbXSwgb3B0cyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLiNpZ25vcmUuYWRkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9ICdjYW5ub3QgaWdub3JlIGNoaWxkIG1hdGNoZXMsIGlnbm9yZSBsYWNrcyBhZGQoKSBtZXRob2QuJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWdub3JlLCBhbHdheXMgc2V0IHdpdGggbWF4RGVwdGgsIGJ1dCBpdCdzIG9wdGlvbmFsIG9uIHRoZVxuICAgICAgICAvLyBHbG9iT3B0aW9ucyB0eXBlXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB0aGlzLm1heERlcHRoID0gb3B0cy5tYXhEZXB0aCB8fCBJbmZpbml0eTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKG9wdHMuc2lnbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuICAgICAgICAgICAgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jb25SZXN1bWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICNpZ25vcmVkKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vlbi5oYXMocGF0aCkgfHwgISF0aGlzLiNpZ25vcmU/Lmlnbm9yZWQ/LihwYXRoKTtcbiAgICB9XG4gICAgI2NoaWxkcmVuSWdub3JlZChwYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2lnbm9yZT8uY2hpbGRyZW5JZ25vcmVkPy4ocGF0aCk7XG4gICAgfVxuICAgIC8vIGJhY2twcmVzc3VyZSBtZWNoYW5pc21cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKCF0aGlzLnBhdXNlZCAmJiAoZm4gPSB0aGlzLiNvblJlc3VtZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlc3VtZShmbikge1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI29uUmVzdW1lLnB1c2goZm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRvIHRoZSByZXF1aXNpdGUgcmVhbHBhdGgvc3RhdCBjaGVja2luZywgYW5kIHJldHVybiB0aGUgcGF0aFxuICAgIC8vIHRvIGFkZCBvciB1bmRlZmluZWQgdG8gZmlsdGVyIGl0IG91dC5cbiAgICBhc3luYyBtYXRjaENoZWNrKGUsIGlmRGlyKSB7XG4gICAgICAgIGlmIChpZkRpciAmJiB0aGlzLm9wdHMubm9kaXIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcnBjO1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlYWxwYXRoKSB7XG4gICAgICAgICAgICBycGMgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgKGF3YWl0IGUucmVhbHBhdGgoKSk7XG4gICAgICAgICAgICBpZiAoIXJwYylcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZSA9IHJwYztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZWVkU3RhdCA9IGUuaXNVbmtub3duKCkgfHwgdGhpcy5vcHRzLnN0YXQ7XG4gICAgICAgIGNvbnN0IHMgPSBuZWVkU3RhdCA/IGF3YWl0IGUubHN0YXQoKSA6IGU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZm9sbG93ICYmIHRoaXMub3B0cy5ub2RpciAmJiBzPy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBzLnJlYWxwYXRoKCk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgKHRhcmdldC5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0YXJnZXQubHN0YXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hDaGVja1Rlc3QocywgaWZEaXIpO1xuICAgIH1cbiAgICBtYXRjaENoZWNrVGVzdChlLCBpZkRpcikge1xuICAgICAgICByZXR1cm4gKGUgJiZcbiAgICAgICAgICAgICh0aGlzLm1heERlcHRoID09PSBJbmZpbml0eSB8fCBlLmRlcHRoKCkgPD0gdGhpcy5tYXhEZXB0aCkgJiZcbiAgICAgICAgICAgICghaWZEaXIgfHwgZS5jYW5SZWFkZGlyKCkpICYmXG4gICAgICAgICAgICAoIXRoaXMub3B0cy5ub2RpciB8fCAhZS5pc0RpcmVjdG9yeSgpKSAmJlxuICAgICAgICAgICAgKCF0aGlzLm9wdHMubm9kaXIgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5vcHRzLmZvbGxvdyB8fFxuICAgICAgICAgICAgICAgICFlLmlzU3ltYm9saWNMaW5rKCkgfHxcbiAgICAgICAgICAgICAgICAhZS5yZWFscGF0aENhY2hlZCgpPy5pc0RpcmVjdG9yeSgpKSAmJlxuICAgICAgICAgICAgIXRoaXMuI2lnbm9yZWQoZSkpID9cbiAgICAgICAgICAgIGVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBtYXRjaENoZWNrU3luYyhlLCBpZkRpcikge1xuICAgICAgICBpZiAoaWZEaXIgJiYgdGhpcy5vcHRzLm5vZGlyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJwYztcbiAgICAgICAgaWYgKHRoaXMub3B0cy5yZWFscGF0aCkge1xuICAgICAgICAgICAgcnBjID0gZS5yZWFscGF0aENhY2hlZCgpIHx8IGUucmVhbHBhdGhTeW5jKCk7XG4gICAgICAgICAgICBpZiAoIXJwYylcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZSA9IHJwYztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZWVkU3RhdCA9IGUuaXNVbmtub3duKCkgfHwgdGhpcy5vcHRzLnN0YXQ7XG4gICAgICAgIGNvbnN0IHMgPSBuZWVkU3RhdCA/IGUubHN0YXRTeW5jKCkgOiBlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmZvbGxvdyAmJiB0aGlzLm9wdHMubm9kaXIgJiYgcz8uaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcy5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgKHRhcmdldD8uaXNVbmtub3duKCkgfHwgdGhpcy5vcHRzLnN0YXQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmxzdGF0U3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoQ2hlY2tUZXN0KHMsIGlmRGlyKTtcbiAgICB9XG4gICAgbWF0Y2hGaW5pc2goZSwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQoZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHdlIGtub3cgd2UgaGF2ZSBhbiBpZ25vcmUgaWYgdGhpcyBpcyBmYWxzZSwgYnV0IFRTIGRvZXNuJ3RcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMgJiYgdGhpcy4jaWdub3JlPy5hZGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlnbiA9IGAke2UucmVsYXRpdmVQb3NpeCgpfS8qKmA7XG4gICAgICAgICAgICB0aGlzLiNpZ25vcmUuYWRkKGlnbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJzID0gdGhpcy5vcHRzLmFic29sdXRlID09PSB1bmRlZmluZWQgPyBhYnNvbHV0ZSA6IHRoaXMub3B0cy5hYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5zZWVuLmFkZChlKTtcbiAgICAgICAgY29uc3QgbWFyayA9IHRoaXMub3B0cy5tYXJrICYmIGUuaXNEaXJlY3RvcnkoKSA/IHRoaXMuI3NlcCA6ICcnO1xuICAgICAgICAvLyBvaywgd2UgaGF2ZSB3aGF0IHdlIG5lZWQhXG4gICAgICAgIGlmICh0aGlzLm9wdHMud2l0aEZpbGVUeXBlcykge1xuICAgICAgICAgICAgdGhpcy5tYXRjaEVtaXQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWJzKSB7XG4gICAgICAgICAgICBjb25zdCBhYnMgPSB0aGlzLm9wdHMucG9zaXggPyBlLmZ1bGxwYXRoUG9zaXgoKSA6IGUuZnVsbHBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hFbWl0KGFicyArIG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVsID0gdGhpcy5vcHRzLnBvc2l4ID8gZS5yZWxhdGl2ZVBvc2l4KCkgOiBlLnJlbGF0aXZlKCk7XG4gICAgICAgICAgICBjb25zdCBwcmUgPSB0aGlzLm9wdHMuZG90UmVsYXRpdmUgJiYgIXJlbC5zdGFydHNXaXRoKCcuLicgKyB0aGlzLiNzZXApID9cbiAgICAgICAgICAgICAgICAnLicgKyB0aGlzLiNzZXBcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaEVtaXQoIXJlbCA/ICcuJyArIG1hcmsgOiBwcmUgKyByZWwgKyBtYXJrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBtYXRjaChlLCBhYnNvbHV0ZSwgaWZEaXIpIHtcbiAgICAgICAgY29uc3QgcCA9IGF3YWl0IHRoaXMubWF0Y2hDaGVjayhlLCBpZkRpcik7XG4gICAgICAgIGlmIChwKVxuICAgICAgICAgICAgdGhpcy5tYXRjaEZpbmlzaChwLCBhYnNvbHV0ZSk7XG4gICAgfVxuICAgIG1hdGNoU3luYyhlLCBhYnNvbHV0ZSwgaWZEaXIpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMubWF0Y2hDaGVja1N5bmMoZSwgaWZEaXIpO1xuICAgICAgICBpZiAocClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hGaW5pc2gocCwgYWJzb2x1dGUpO1xuICAgIH1cbiAgICB3YWxrQ0IodGFyZ2V0LCBwYXR0ZXJucywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2Fsa0NCMih0YXJnZXQsIHBhdHRlcm5zLCBuZXcgUHJvY2Vzc29yKHRoaXMub3B0cyksIGNiKTtcbiAgICB9XG4gICAgd2Fsa0NCMih0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzLiNjaGlsZHJlbklnbm9yZWQodGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXN1bWUoKCkgPT4gdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzb3IucHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpO1xuICAgICAgICAvLyBkb25lIHByb2Nlc3NpbmcuICBhbGwgb2YgdGhlIGFib3ZlIGlzIHN5bmMsIGNhbiBiZSBhYnN0cmFjdGVkIG91dC5cbiAgICAgICAgLy8gc3Vid2Fsa3MgaXMgYSBtYXAgb2YgcGF0aHMgdG8gdGhlIGVudHJ5IGZpbHRlcnMgdGhleSBuZWVkXG4gICAgICAgIC8vIG1hdGNoZXMgaXMgYSBtYXAgb2YgcGF0aHMgdG8gW2Fic29sdXRlLCBpZkRpcl0gdHVwbGVzLlxuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIHRoaXMubWF0Y2gobSwgYWJzb2x1dGUsIGlmRGlyKS50aGVuKCgpID0+IG5leHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHByb2Nlc3Nvci5zdWJ3YWxrVGFyZ2V0cygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgJiYgdC5kZXB0aCgpID49IHRoaXMubWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkNhY2hlZCA9IHQucmVhZGRpckNhY2hlZCgpO1xuICAgICAgICAgICAgaWYgKHQuY2FsbGVkUmVhZGRpcigpKVxuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0NCMyh0LCBjaGlsZHJlbkNhY2hlZCwgcHJvY2Vzc29yLCBuZXh0KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQucmVhZGRpckNCKChfLCBlbnRyaWVzKSA9PiB0aGlzLndhbGtDQjModCwgZW50cmllcywgcHJvY2Vzc29yLCBuZXh0KSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICB3YWxrQ0IzKHRhcmdldCwgZW50cmllcywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZmlsdGVyRW50cmllcyh0YXJnZXQsIGVudHJpZXMpO1xuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIHRoaXMubWF0Y2gobSwgYWJzb2x1dGUsIGlmRGlyKS50aGVuKCgpID0+IG5leHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbdGFyZ2V0LCBwYXR0ZXJuc10gb2YgcHJvY2Vzc29yLnN1YndhbGtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCMih0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IuY2hpbGQoKSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICB3YWxrQ0JTeW5jKHRhcmdldCwgcGF0dGVybnMsIGNiKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIG5ldyBQcm9jZXNzb3IodGhpcy5vcHRzKSwgY2IpO1xuICAgIH1cbiAgICB3YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzLiNjaGlsZHJlbklnbm9yZWQodGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXN1bWUoKCkgPT4gdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IsIGNiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3NQYXR0ZXJucyh0YXJnZXQsIHBhdHRlcm5zKTtcbiAgICAgICAgLy8gZG9uZSBwcm9jZXNzaW5nLiAgYWxsIG9mIHRoZSBhYm92ZSBpcyBzeW5jLCBjYW4gYmUgYWJzdHJhY3RlZCBvdXQuXG4gICAgICAgIC8vIHN1YndhbGtzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIHRoZSBlbnRyeSBmaWx0ZXJzIHRoZXkgbmVlZFxuICAgICAgICAvLyBtYXRjaGVzIGlzIGEgbWFwIG9mIHBhdGhzIHRvIFthYnNvbHV0ZSwgaWZEaXJdIHR1cGxlcy5cbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hTeW5jKG0sIGFic29sdXRlLCBpZkRpcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHByb2Nlc3Nvci5zdWJ3YWxrVGFyZ2V0cygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEZXB0aCAhPT0gSW5maW5pdHkgJiYgdC5kZXB0aCgpID49IHRoaXMubWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2tzKys7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHQucmVhZGRpclN5bmMoKTtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCM1N5bmModCwgY2hpbGRyZW4sIHByb2Nlc3NvciwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICB3YWxrQ0IzU3luYyh0YXJnZXQsIGVudHJpZXMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgcHJvY2Vzc29yID0gcHJvY2Vzc29yLmZpbHRlckVudHJpZXModGFyZ2V0LCBlbnRyaWVzKTtcbiAgICAgICAgbGV0IHRhc2tzID0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLXRhc2tzID09PSAwKVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgW20sIGFic29sdXRlLCBpZkRpcl0gb2YgcHJvY2Vzc29yLm1hdGNoZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaWdub3JlZChtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hTeW5jKG0sIGFic29sdXRlLCBpZkRpcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbdGFyZ2V0LCBwYXR0ZXJuc10gb2YgcHJvY2Vzc29yLnN1YndhbGtzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLmNoaWxkKCksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR2xvYldhbGtlciBleHRlbmRzIEdsb2JVdGlsIHtcbiAgICBtYXRjaGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHBhdHRlcm5zLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgbWF0Y2hFbWl0KGUpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlKTtcbiAgICB9XG4gICAgYXN5bmMgd2FsaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5zaWduYWwucmVhc29uO1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhdGgubHN0YXQoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWoodGhpcy5zaWduYWwucmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyh0aGlzLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICB9XG4gICAgd2Fsa1N5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgdGhpcy5wYXRoLmxzdGF0U3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGhpbmcgZm9yIHRoZSBjYWxsYmFjayB0byBkbywgYmVjYXVzZSB0aGlzIG5ldmVyIHBhdXNlc1xuICAgICAgICB0aGlzLndhbGtDQlN5bmModGhpcy5wYXRoLCB0aGlzLnBhdHRlcm5zLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5zaWduYWwucmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR2xvYlN0cmVhbSBleHRlbmRzIEdsb2JVdGlsIHtcbiAgICByZXN1bHRzO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHBhdHRlcm5zLCBwYXRoLCBvcHRzKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gbmV3IE1pbmlwYXNzKHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN1bHRzLm9uKCdkcmFpbicsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLnJlc3VsdHMub24oJ3Jlc3VtZScsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgIH1cbiAgICBtYXRjaEVtaXQoZSkge1xuICAgICAgICB0aGlzLnJlc3VsdHMud3JpdGUoZSk7XG4gICAgICAgIGlmICghdGhpcy5yZXN1bHRzLmZsb3dpbmcpXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0YXJnZXQubHN0YXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtDQih0YXJnZXQsIHRoaXMucGF0dGVybnMsICgpID0+IHRoaXMucmVzdWx0cy5lbmQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRhcmdldCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGgubHN0YXRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/esm/walker.js\n");

/***/ })

};
;